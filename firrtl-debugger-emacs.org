* firrtl-debugger-emacs
** Headers
*** Purpose

Record the design and development of a FIRRTL debugging interface for emacs

*** History

Begun Thu Apr 30 16:45:04 2020

*** File marks
#+SETUPFILE: ~/.emacs.d/org-setups/design.org
*** Associated files

** Design
** Info
** Issues
** Progress
** Communication
** Notes
*** First things to do

 * [ ] Capture "show" output
 * [X] Parse "show" output
   * Registers
   * [X] Circuit state
 * [X] Decide [[id:9282c996-d57a-4556-b167-530cf50a11f5][Whether to start directly]]
 * [ ] Startup
   * Now it's just a comint launch

*** Plan for general interaction

The registers etc live in a widget tree.

We can pin various ones high, other ones sort as they come out.  Or
just open them.  Maybe some way to save that.

New ones are just captured.

The inputs can be written to manually or programmatically.  poke
inputPortName value and mempoke should be done automatically.

Some button gets us "step; show; "  We may not need peek, mempeek.

We capture circuit info and display it in a different window.

*** Whether to start directly
    :PROPERTIES:
    :ID:       9282c996-d57a-4556-b167-530cf50a11f5
    :END:

We could try to work thru sbt mode.  But that brings in all sorts of
hair.

Starting directly just works.

 : sbt 'test:runMain gcd.GCDRepl'

puts us into the REPL, which we can capture directly.

Even comint mode seems too much.  Just capture into a buffer.

*** Parsing "show" output

(Equivalently "show" or "show state")

 * CircuitState
 * Inputs:
 * Outputs:
 * Registers      :
 * FutureRegisters:
   * Associated to registers
 * Ephemera:
 * Memories

Each register display is of the form Name=Value, separated by ", "
except the last.  Value can be bracketed by "â˜ ".  Inside that, Value
is preceded by whitespace.

Name is dot-separated components.  Each component may be suffixed with
_N indicating part of a vector.

*** type

We'd like to run "type regex" on each thing and associate that to its
name.  But that may take a while.

*** eval

On a thing, to show trace of computation

*** waitfor
waitfor componentName value

Possibly wrt a componentName we point at
*** Other commands
show lofirrtl (We'd just capture it into a buffer)
show input (This would require way more parsing)
reset
randomize (Randomizes inputs, so it overlaps with us)
poison
timing (Shows it)
timing clear
timing bin (Not clear what it does)
Setting flags: {ordered-exec,allow-cycles,eval-all}
load fileName (Loads a whole new file.  We'd better reset)

And that's about it.  Other existing commands are pointless in this
environment.

*** About type

Some sample outputs
 : type _T_5 0.U<1>
 : type x 2.PU<4>
 : type _GEN_3 17368.PU<16>
 : type clock 0.U<1>
 : type reset 0.U<1>
 : type io_loadingValues 1.PU<1>
 : type io_outputValid 0.U<1>

Does "PU" indicate an explicitly created component, while "U" is
automatically made?  No, io_outputValid seems explicitly made but has
"U"

At some point we'll have to change the error message regex

**** Error
Sorry now settable ports matched regex _GEN_1

*** About poke

We can poke to any component, even registers.  But the pokes into
arbitrary locations don't persist after stepping.  Basically if the
state is "FRESH", all pokes other than to inputs are gone.

**** Components disappear

Some components disappeared after I poked an ephemeral value.  But not
due to the poke.  I reloaded the file, did nothing but step it, and
the same ephemeral components disappeared.

Reloading worked
 : load /home/tehom/projects/ic-fab/ChiselProjects/tryout-chisel/test_run_dir/gcd.GCDRepl900447983/GCD.fir

**** An error from too-wide poke

Error: exception error: ConcreteUInt(72, 4) bad width 4 needs 7 firrtl_interpreter.InterpreterException: error: ConcreteUInt(72, 4) bad width 4 needs 7
**** An error from negative poke

Error: exception error: ConcreteUInt(-1, 4) bad value -1 must be >= 0 firrtl_interpreter.InterpreterException: error: ConcreteUInt(-1, 4) bad value -1 must be >= 0
**** An exception from peek to a gone component

Error: exception Error: getValue(_GEN_0) returns value not found
*** Tree widget doesn't co-operate with widgets

Approaches:
 * Lots more work
 * CHOSEN Let input's action do a dialog instead

**** About it

I had originally intended to just use more widgets for the
interaction, but that doesn't work.  Specifically, it doesn't play
well with the tree expansion widgets.  Widgets that are originally
folded require manual setup, and that setup doesn't go away when they
are re-folded.  So then you get overlapping fields, and that's a big
problem.

So I just resorted to an interaction dialog in the low bar.
*** About enums

This will likely be part of a larger customization about FIRRTL
variables.  

We'd customize:
 * type (enum by name, hex, decimal, binary, boolean)
 * sorting order
 * whether trees start open or folded

By default,
 * io sorts earliest and starts open
 * type includes boolean and hex
 * reset is its own thing (invisible?)
 * clock is its own thing (invisible?)

But "type" applies to individual variables.  It could apply on
patterns too.  But it's never going to apply to inner nodes, as the
other things do.  And you typically wouldn't want to treat type and
the other things together.

Nice to have:
 * Var customizer completes from variables the obarray knows about
 * Store these customizations in the current directory.

**** Development

 * [ ] Build and use any converter (say hex or binary with string-to-number)
 * [ ] Make a var customizer
 * [ ] Apply those customizations to a sym value / to all in the obarray.
 * [ ] Use those customizations to display

*** More things to do

 * [X] Add buttons and shortcuts for the functionality (step&show, multistep, reset)
   * Did just one, but the others are basically the same
 * [X] Just if it's input, insert a value modification widget.
   * This strategy won't work, but did it as interaction
 * [X] Allow hex or bin values, and arbitrary user value conversions (enums)
 * [X] Another buffer and structure defining enum value conversions
   * It's a customization.
 * [X] Darker face if it's invalid (:value-face)
 * [ ] Sort them first: alphabetical and input/output/other
   * And by user customization
 * [ ] Pre-open some of them.
   * Easy to do but only nice to have.
 * [ ] Add something to save a configuration
   * Really, to save these customizations.  That's basically cloning
     code in cus-edit, with a different means of finding the affected
     variables and a different target file.
   * Or let each circuit be its own entry in a list of customizations.
     But that makes all sorts of code parse that list.
   * Or just save the values straight, and read them back straight.
   * Yes, visit it in a buffer.  As p-sexps does.  Use my tiny-db /
     persist package.
 * [ ] For customizations, add the values of a circuit's symbols to
   the completions.
   * custom-add-frequent-value doesn't help us
   * Maybe instead a dialog launched by clicking on that symbol?
     * Except firrtl-dbg-do-integer-edit&poke doesn't make that
       distinction.
   * We already have one, but maybe with \C-u launch a different one.
   * Still want the option of using regular expressions to recognize
     components.
   * Maybe another command in the keymap?  And when executed at that
     location, it launches this interaction.

**** Design of editing a symbol's type

This acts, but of course complains that this has no custom-type
property.

 : (customize-option (intern "io_value1" firrtl-dbg-obarray))

Could give each symbol a custom-type.

Also, customize wants to edit its value, which is generally wrong.  

Approaches:
 * Make customize edit its plist instead
   * Con: Can't.
 * Make customize edit its entry in firrtl-dbg-custom-variable-formats
   * Con: Can't launch
   * Con: Can't store
 * Let that symbol's value contain both its current data and its spec.
   * Con: That's really really wrong for saving and restoring it.
 * LEANING_TOWARDS Also intern the same string in another obarray for
   its permanent properties
   * An entry is only needed there if we have set permanent properties
     for it.
   * Con: Doesn't let us do regexps.  But we were really after partial
     component paths.
     * Perhaps each perm symbol lets us get to all regexps or
       paths-with-vars that applied to it.




